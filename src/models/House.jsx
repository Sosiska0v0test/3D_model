/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { events, useFrame, useThree } from '@react-three/fiber'
import { animated } from "@react-spring/three";

import houseScene from '../../assets/house.glb'

const House = ({ isRotating, setIsRotating, setCurrentStage, ...props }) => {
  const houseRef = useRef();

  const { gl, viewport } = useThree();
  const { nodes, materials } = useGLTF(houseScene)

  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlePointerDown = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setIsRotating(true);

    const clientX = event.touches ? event.touches[0].clientX : event.clientX;

    lastX.current = clientX;
  };

  const handlePointerUp = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setIsRotating(false);
  };

  const handlePointerMove = (event) => {
    event.stopPropagation();
    event.preventDefault();
    if (isRotating) {
      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const delta = (clientX - lastX.current) / viewport.width;
      houseRef.current.rotation.y += delta * 0.01 * Math.PI;
      lastX.current = clientX;
      rotationSpeed.current = delta * 0.01 * Math.PI;
    }
  };


  // Handle keydown events
  const handleKeyDown = (event) => {
    if (event.key === "ArrowLeft") {
      if (!isRotating) setIsRotating(true);

      houseRef.current.rotation.y += 0.005 * Math.PI;
      rotationSpeed.current = 0.007;
    } else if (event.key === "ArrowRight") {
      if (!isRotating) setIsRotating(true);

      houseRef.current.rotation.y -= 0.005 * Math.PI;
      rotationSpeed.current = -0.007;
    }
  };

  const handleKeyUp = (event) => {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
      setIsRotating(false);
    }
  };

  const handleTouchStart = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    lastX.current = clientX;
  }

  const handleTouchEnd = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
  }

  const handleTouchMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if (isRotating) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const delta = (clientX - lastX.current) / viewport.width;

      houseRef.current.rotation.y += delta * 0.01 * Math.PI;
      lastX.current = clientX;
      rotationSpeed.current = delta * 0.01 * Math.PI;
    }
  }

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    canvas.addEventListener("touchstart", handleTouchStart);
    canvas.addEventListener("touchend", handleTouchEnd);
    canvas.addEventListener("touchmove", handleTouchMove);

    return () => {
      canvas.removeEventListener("pointerdown", handlePointerDown);
      canvas.removeEventListener("pointerup", handlePointerUp);
      canvas.removeEventListener("pointermove", handlePointerMove);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      canvas.removeEventListener("touchstart", handleTouchStart);
      canvas.removeEventListener("touchend", handleTouchEnd);
      canvas.removeEventListener("touchmove", handleTouchMove);
    };
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);

  useFrame(() => {
    if (!isRotating) {
      rotationSpeed.current *= dampingFactor;

      if (Math.abs(rotationSpeed.current) < 0.01) {
        rotationSpeed.current = 0.001;
      }

      houseRef.current.rotation.y += rotationSpeed.current;
    } else {
      const rotation = houseRef.current.rotation.y;

      const normalizedRotation =
        ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

      switch (true) {
        case normalizedRotation >= 5.41 && normalizedRotation <= 5.85:
          setCurrentStage(4);
          break;
        case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
          setCurrentStage(3);
          break;
        case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
          setCurrentStage(2);
          break;
        case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
          setCurrentStage(1);
          break;
        default:
          setCurrentStage(null);
      }
    }
  });

  return (
    <animated.group ref={ houseRef } { ...props }>
      <mesh
        geometry={ nodes.Cube052.geometry }
        material={ nodes.Cube052.material }
        scale={ 0.478 }>
        <mesh
          geometry={ nodes.Cube016.geometry }
          material={ materials.tehly }
          scale={ 2.09 }
        />
        <mesh
          geometry={ nodes.Cube024.geometry }
          material={ materials.omietka }
          scale={ [2.09, 2.09, 1.716] }
        />
        <mesh
          geometry={ nodes.Cube039.geometry }
          material={ materials.drevo }
          scale={ 2.09 }
        />
        <mesh
          geometry={ nodes.Cube049.geometry }
          material={ materials.tehla }
          scale={ [7.075, 7.075, 3.223] }
        />
        <mesh
          geometry={ nodes.Cube100.geometry }
          material={ materials.komin }
          scale={ 1.578 }
        />
        <mesh
          geometry={ nodes.Cube229.geometry }
          material={ materials.studna }
          rotation={ [-0.007, -0.392, -0.003] }
          scale={ [4.615, 3.555, 5.608] }
        />
        <mesh
          geometry={ nodes.Plane.geometry }
          material={ materials['Material.001'] }
          scale={ 2.09 }
        />
        <mesh
          geometry={ nodes.Plane001.geometry }
          material={ materials.soil }
          scale={ 2.045 }
        />
        <mesh
          geometry={ nodes.Plane003.geometry }
          material={ materials.sklo }
          rotation={ [0, 0.417, 1.566] }
          scale={ [0.519, 0.29, 0.387] }
        />
        <mesh
          geometry={ nodes.skla_a_dym_mergedObject002.geometry }
          material={ materials.Material }
          scale={ 2.09 }
        />
        <mesh
          geometry={ nodes.Sphere001.geometry }
          material={ materials['Material.002'] }
          rotation={ [-Math.PI, -0.316, -Math.PI] }
          scale={ 0.335 }
        />
      </mesh>
    </animated.group>
  )
}

export default House;